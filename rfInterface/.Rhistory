keep[obsPeaks[1]] <- 1  # keep first peak to start with
#peak validation
for (i in 2:length(obsPeaks)) {
now <- obsPeaks[i]
prev <- max(intersect(obsPeaks[1:(i-1)], which(keep==1)))
# which still remaining obsPeak occured most recently
keep[now] <- 1
tp <- sub$time[prev]
fp <- sub$flow[prev]
tn <- sub$time[now]
fn <- sub$flow[now]
if (fn == fp) {
smallest <- prev
}else{
smallest <- ifelse(sub$flow[prev] < sub$flow[now], prev, now)
}
if ((tn - tp) < mintimeDiff) {
keep[smallest] <- 0
}else{
minThrough <- min(sub$flow[(prev+1):(now-1)])
if (minThrough > (min(fp, fn) * thrConst)) {
keep[smallest] <- 0
}
}
}
# formatting for output
isPeak <- rep(0, NR)
isPeak[cc$pos] <- keep
isPeak[ObsEA] <- 0
pot <- tt[isPeak == 1, ]
pot[, 1] <- datetime_real
return(list(is_peak=isPeak, pot=pot))
}
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
poty <- extractPeaksMod(1:100,xt,5,(2/3), threshold=quantile(xt, 0.9))
debug(extractPeaksMod)
poty <- extractPeaksMod(1:100,xt,5,(2/3), threshold=quantile(xt, 0.9))
extractPeaksMod <- function (datetime = NULL,
series,
timeOfRise = 73,
thrConst = (2/3),
threshold = NULL) {
# if (is.null(datetime)) {
#   datetime <- seq_along(series)
# }
# if (!is.numeric(datetime)) {
#   warning("Time should be numeric")
# }
#
# if (is.null(threshold)){
#   threshold <- quantile(series,  0.9)
# }
if (!is.data.frame(series)) {
if (is.null(datetime)){
datetime_real <- 1:length(series)
}
datetime_real <- datetime
series <- data.frame(datetime=1:length(series), series=series)
} else {
datetime_real <- sort(series[, 1])
series$datetime <- order(series[, 1])
}
mintimeDiff <- 3*timeOfRise
#setup
tt <- series
names(tt) <- c("time", "obs")
tt <- tt[order(tt$time), ]
NR <- nrow(tt)
#find all the peaks and troughs
cc <- pastecs::turnpoints(tt$obs)  # cc$pos is timepoints without tied values
NP <- length(cc$pos)
sub <- data.frame(time = tt$time[cc$pos],
flow = tt$obs[cc$pos],
peak = cc$peaks,  # peak = 1, nonpeak = 0
pit = cc$pits)  # pits = troughs
sub$peak[sub$flow < threshold] <- 0  # remove peaks below threshold
keep <-     rep(0, NP)
ObsEA <-    (1:NR)[-cc$pos]
obsPeaks <- which(sub$peak == 1)
obsPits <-  which(sub$pit  == 1)
keep[obsPeaks[1]] <- 1  # keep first peak to start with
#peak validation
for (i in 2:length(obsPeaks)) {
now <- obsPeaks[i]
prev <- max(intersect(obsPeaks[1:(i-1)], which(keep==1)))
# which still remaining obsPeak occured most recently
keep[now] <- 1
tp <- sub$time[prev]
fp <- sub$flow[prev]
tn <- sub$time[now]
fn <- sub$flow[now]
if (fn == fp) {
smallest <- prev
}else{
smallest <- ifelse(sub$flow[prev] < sub$flow[now], prev, now)
}
if ((tn - tp) < mintimeDiff) {
keep[smallest] <- 0
}else{
minThrough <- min(sub$flow[(prev+1):(now-1)])
if (minThrough > (min(fp, fn) * thrConst)) {
keep[smallest] <- 0
}
}
}
# formatting for output
isPeak <- rep(0, NR)
isPeak[cc$pos] <- keep
isPeak[ObsEA] <- 0
pot <- tt[isPeak == 1, ]
pot[, 1] <- datetime_real
return(list(is_peak=isPeak, pot=pot))
}
debug(extractPeaksMod)
poty <- extractPeaksMod(1:100,xt,5,(2/3), threshold=quantile(xt, 0.9))
extractPeaksMod <- function (datetime = NULL,
series,
timeOfRise = 73,
thrConst = (2/3),
threshold = NULL) {
# if (is.null(datetime)) {
#   datetime <- seq_along(series)
# }
# if (!is.numeric(datetime)) {
#   warning("Time should be numeric")
# }
#
# if (is.null(threshold)){
#   threshold <- quantile(series,  0.9)
# }
if (!is.data.frame(series)) {
if (is.null(datetime)){
datetime_real <- 1:length(series)
}
datetime_real <- datetime
series <- data.frame(datetime=1:length(series), series=series)
} else {
datetime_real <- sort(series[, 1])
series$datetime <- order(series[, 1])
}
mintimeDiff <- 3*timeOfRise
#setup
tt <- series
names(tt) <- c("time", "obs")
tt <- tt[order(tt$time), ]
NR <- nrow(tt)
#find all the peaks and troughs
cc <- pastecs::turnpoints(tt$obs)  # cc$pos is timepoints without tied values
NP <- length(cc$pos)
sub <- data.frame(time = tt$time[cc$pos],
flow = tt$obs[cc$pos],
peak = cc$peaks,  # peak = 1, nonpeak = 0
pit = cc$pits)  # pits = troughs
sub$peak[sub$flow < threshold] <- 0  # remove peaks below threshold
keep <-     rep(0, NP)
ObsEA <-    (1:NR)[-cc$pos]
obsPeaks <- which(sub$peak == 1)
obsPits <-  which(sub$pit  == 1)
keep[obsPeaks[1]] <- 1  # keep first peak to start with
#peak validation
for (i in 2:length(obsPeaks)) {
now <- obsPeaks[i]
prev <- max(intersect(obsPeaks[1:(i-1)], which(keep==1)))
# which still remaining obsPeak occured most recently
keep[now] <- 1
tp <- sub$time[prev]
fp <- sub$flow[prev]
tn <- sub$time[now]
fn <- sub$flow[now]
if (fn == fp) {
smallest <- prev
}else{
smallest <- ifelse(sub$flow[prev] < sub$flow[now], prev, now)
}
if ((tn - tp) < mintimeDiff) {
keep[smallest] <- 0
}else{
minThrough <- min(sub$flow[(prev+1):(now-1)])
if (minThrough > (min(fp, fn) * thrConst)) {
keep[smallest] <- 0
}
}
}
# formatting for output
isPeak <- rep(0, NR)
isPeak[cc$pos] <- keep
isPeak[ObsEA] <- 0
pot <- tt[isPeak == 1, ]
pot[, 1] <- datetime_real[isPeak == 1]
return(list(is_peak=isPeak, pot=pot))
}
debug(extractPeaksMod)
poty <- extractPeaksMod(1:100,xt,5,(2/3), threshold=quantile(xt, 0.9))
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_Peak==1], xt[poty$is_Peak==1], col='red', pch=2)
points(poty$pot, col="green", pch=4)
dt[poty$is_Peak==1]
poty$is_Peak==1
poty$is_Peak
poty$is_peak
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
potx <- ilaprosUtils::extractPeaks(1:100,xt,5,(2/3))
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
points(poty$pot, col="green", pch=4)
poty$pot
points(dt[poty$pot$time], poty$pot$obs, col="green", pch=4)
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,5,(2/3))
poty <- extractPeaksMod(dt,xt,5,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(dt[poty$pot$time], poty$pot$obs, col="green", pch=4)
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,5,(2/3))
poty <- extractPeaksMod(dt,xt,5,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty$is_peak)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(dt[poty$pot$time], poty$pot$obs, col="green", pch=4)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
extractPeaksMod <- function (datetime = NULL,
series,
timeOfRise = 73,
thrConst = (2/3),
threshold = NULL) {
# if (is.null(datetime)) {
#   datetime <- seq_along(series)
# }
# if (!is.numeric(datetime)) {
#   warning("Time should be numeric")
# }
#
# if (is.null(threshold)){
#   threshold <- quantile(series,  0.9)
# }
if (!is.data.frame(series)) {
if (is.null(datetime)){
datetime_real <- 1:length(series)
}
datetime_real <- datetime
series <- data.frame(datetime=1:length(series), series=series)
} else {
datetime_real <- sort(series[, 1])
series$datetime <- order(series[, 1])
}
mintimeDiff <- 3*timeOfRise
#setup
tt <- series
names(tt) <- c("time", "obs")
tt <- tt[order(tt$time), ]
NR <- nrow(tt)
#find all the peaks and troughs
cc <- pastecs::turnpoints(tt$obs)  # cc$pos is timepoints without tied values
NP <- length(cc$pos)
sub <- data.frame(time = tt$time[cc$pos],
flow = tt$obs[cc$pos],
peak = cc$peaks,  # peak = 1, nonpeak = 0
pit = cc$pits)  # pits = troughs
sub$peak[sub$flow < threshold] <- 0  # remove peaks below threshold
keep <-     rep(0, NP)
ObsEA <-    (1:NR)[-cc$pos]
obsPeaks <- which(sub$peak == 1)
obsPits <-  which(sub$pit  == 1)
keep[obsPeaks[1]] <- 1  # keep first peak to start with
#peak validation
for (i in 2:length(obsPeaks)) {
now <- obsPeaks[i]
prev <- max(intersect(obsPeaks[1:(i-1)], which(keep==1)))
# which still remaining obsPeak occured most recently
keep[now] <- 1
tp <- sub$time[prev]
fp <- sub$flow[prev]
tn <- sub$time[now]
fn <- sub$flow[now]
if (fn == fp) {
smallest <- prev
}else{
smallest <- ifelse(sub$flow[prev] < sub$flow[now], prev, now)
}
if ((tn - tp) < mintimeDiff) {
keep[smallest] <- 0
}else{
minThrough <- min(sub$flow[(prev+1):(now-1)])
if (minThrough > (min(fp, fn) * thrConst)) {
keep[smallest] <- 0
}
}
}
# formatting for output
isPeak <- rep(0, NR)
isPeak[cc$pos] <- keep
isPeak[ObsEA] <- 0
pot <- tt[isPeak == 1, ]
pot[, 1] <- datetime_real[isPeak == 1]
return(list(is_peak=isPeak, pot=pot))
}
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,5,(2/3))
poty <- extractPeaksMod(dt,xt,5,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty$is_peak)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(dt[poty$pot$time], poty$pot$obs, col="green", pch=4)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
points(poty$pot$time, poty$pot$obs, col="green", pch=4)
poty$POT
poty$pot
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,5,(2/3))
poty <- extractPeaksMod(dt,xt,5,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty$is_peak)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(poty$pot$time, poty$pot$obs, col="green", pch=4)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,5,(2/3))
poty <- extractPeaksMod(dt,xt,5,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty$is_peak)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(poty$pot$time, poty$pot$obs, col="green", pch=4)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,5,(2/3))
poty <- extractPeaksMod(dt,xt,5,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty$is_peak)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(poty$pot$time, poty$pot$obs, col="green", pch=4)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,2,(2/3))
poty <- extractPeaksMod(dt,xt,2,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty$is_peak)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(poty$pot$time, poty$pot$obs, col="green", pch=4)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,2,(2/3))
poty <- extractPeaksMod(dt,xt,2,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty$is_peak)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(poty$pot$time, poty$pot$obs, col="green", pch=4)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,2,(2/3))
poty <- extractPeaksMod(dt,xt,2,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty$is_peak)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(poty$pot$time, poty$pot$obs, col="green", pch=4)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,2,(2/3))
poty <- extractPeaksMod(dt,xt,2,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty$is_peak)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(poty$pot$time, poty$pot$obs, col="green", pch=4)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,2,(2/3))
poty <- extractPeaksMod(dt,xt,2,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty$is_peak)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(poty$pot$time, poty$pot$obs, col="green", pch=4)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
autoAxis <- function(series, ...){
X <- as.Date(range(series))
Xseq <- seq(X[1], X[2], by='month')
Xlen <- findInterval(length(Xseq), c(0,12,36,60))
Xseq <- switch(Xlen,
seq(X[1], X[2], by='month'),
seq(X[1], X[2], by='3 months'),
seq(X[1], X[2], by='6 months'),
seq(X[1], X[2], by='year'))
Xlab <- switch(Xlen,
"%b %Y","%b %Y","%b %Y","%Y")
graphics::axis(1, at=Xseq, labels=format(Xseq, Xlab), ...)
graphics::axis(1, at=seq(X[1], X[2], by='month'), labels=F, tick=T)
}
autoaxis(dt)
autoAxis(dt)
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
potx <- ilaprosUtils::extractPeaks(1:100,xt,2,(2/3))
poty <- extractPeaksMod(dt,xt,2,(2/3), threshold=quantile(xt, 0.9))
all(potx==poty$is_peak)
plot(dt,xt, type='l', xaxt='n')
points(dt[potx==1], xt[potx==1], col='blue', pch=3)
points(dt[poty$is_peak==1], xt[poty$is_peak==1], col='red', pch=2)
points(poty$pot$time, poty$pot$obs, col="green", pch=4)
abline(h=quantile(xt,0.9), col="grey50", lty=2)
autoAxis(dt)
library(rfInterface)
library(rfInterface)
library(rfInterface)
devtools::document()
devtools::document()
library(rfInterface)
devtools::check(cleanup = FALSE,args = c('--no-examples'),manual = TRUE,path = getwd())
?check
check(manual=T)
devtools::check(manual=T)
build_manual()
devtools::build_manual()
library(rfInterface)
?POTextract
library(rfInterface)
?POTextract
library(rfInterface)
devtools::document()
current.session()
library(rfInterface)
?POTextract
library(rfInterface)
devtools::document()
devtools::build_manual()
devtools::document()
devtools::build_manual()
?pastecs
library(pastecs)
library(trend)
xt <- (arima.sim(list(order=c(3,0,0), ar=c(0.5,0.25,0.125)), n=100) + 2)^2
dt <- as.Date(1:100, origin="2000-01-01")
mk.test(xt)
plot(dt,xt, type='l', xaxt='n')
mmkk <- mk.test(xt)
mmkk$p.value
mmkk$parameter
mmkk$statistic
mmkk$null.value
mmkk$method
mmkk$estimates
plot(dt,xt, type='l', xaxt='n')
rfInterface:::import_ts(ids="SX67F051", org="EA", dat="gdf", metadata=T)
ra <- rfInterface:::import_ts(ids="SX67F051", org="EA", dat="gdf", metadata=T)
devtools::document()
devtools::build_manual()
stationList("COSMOS")
devtools::document()
devtools::document()
stationList("COSMOS")
devtools::document()
library(rfInterface)
?rfInterface
devtools::document()
devtools::build_manual()
gdf_fetch <- jsonlite::fromJSON(
txt=paste0("https://gateway-staging.ceh.ac.uk/hydrology-ukscape/stations/",
"EA/gdf/723a8fc4-908b-4430-91c7-9990be86540a/1900-01-01/1901-01-01"),
simplifyDataFrame=T)
site_fetch <- jsonlite::fromJSON(
txt="https://gateway-staging.ceh.ac.uk/hydrology-ukscape/stations",
simplifyDataFrame=T)
lookup_fetch <- jsonlite::fromJSON(
txt="https://gateway-staging.ceh.ac.uk/hydrology-ukscape/lookup",
simplifyDataFrame=T)
?exists
exists(lookup_fetch)
exists("lookup_fetch")
install.packages("pastecs")#
library(pastecs)
install.packages("rnrfa")
library(rnrfa)
plot_rain_flow(34034)
plot_rain_flow(id = 54090)
plot_rain_flow(id = 25018)
library(rfInterface)
SF <- site_fetch$data[[1]]
View(SF)
SF <- site_fetch$data[[2]]
plot(SF$latitude, SF$longitude)
plot(SF$longitude, SF$latitude)
devtools::check(document=TRUE)
source('~/UKSCAPE_C/flowAPIpackage/rfInterface/R/hello.R')
library(rfInterface)
rp <- c(5,10,25,100)
1/(1-rp)
1 - (1/rp)
